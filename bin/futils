#!/usr/bin/env bash
# Flattened ... do not modify 
set -o errtrace
set -o functrace
set -o errexit
set -o nounset
set -o pipefail
export PS4='+(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }' 
# Return true (0) if the first string contains the second string
function string_contains() {
    local -r haystack="$1"
    local -r needle="$2"
    [[ "$haystack" == *"$needle"* ]]
}
# Returns true (0) if the first string (assumed to contain multiple lines)
# contains the second string (needle).
# The needle can contain regular expressions.
function string_multiline_contains() {
    local -r haystack="$1"
    local -r needle="$2"
    echo "$haystack" | grep -q "$needle"
}
# Convert the given string to uppercase
function string_to_uppercase() {
    local -r str="$1"
    echo "$str" | awk '{print toupper($0)}'
}
# eg .
# string_strip_prefix "foo=bar" "foo=" ===> "bar"
# string_strip_prefix "foo=bar" "*=" ===> "bar"
function string_strip_prefix() {
    local -r str="$1"
    local -r prefix="$2"
    echo "${str#$prefix}"
}
# eg:
# string_strip_suffix "foo=bar" "=bar" ===> "foo"
# string_strip_suffix "foo=bar" "=*" ===> "foo"
function string_strip_suffix() {
    local -r str="$1"
    local -r suffix="$2"
    echo "${str%$suffix}"
}
# Return true if the given response is empty or "null"
# "null" is from jq parsing.
function string_is_empty_or_null() {
    local -r response="$1"
    [[ -z "$response" || "$response" == "null" ]]
}
# https://misc.flogisoft.com/bash/tip_colors_and_formatting
function string_colorify() {
    local -r input="$2"
    # checking for colour availablity
    ncolors=$(tput colors)
    if [[ $ncolors -ge 8 ]]; then
        local -r color_code="$1"
        echo -e "\e[1m\e[$color_code"m"$input\e[0m"
    else
        echo -e "$input"
    fi
}
function string_blue() {
    local -r color_code="34"
    local -r input="$1"
    echo -e "$(string_colorify "${color_code}" "${input}")"
}
function string_yellow() {
    local -r color_code="93"
    local -r input="$1"
    echo -e "$(string_colorify "${color_code}" "${input}")"
}
function string_green() {
    local -r color_code="32"
    local -r input="$1"
    echo -e "$(string_colorify "${color_code}" "${input}")"
}
function string_red() {
    local -r color_code="31"
    local -r input="$1"
    echo -e "$(string_colorify "${color_code}" "${input}")"
}
function assert_not_empty() {
    local -r arg_name="$1"
    local -r arg_value="$2"
    local -r reason="$3"
    if [[ -z "$arg_value" ]]; then
        log_error "'$arg_name' cannot be empty. $reason"
        exit 1
    fi
}
function unique_id() {
    local length
    local result
    length="$1"
    result="$(head /dev/urandom | tr -dc A-Za-z0-9 | head -c "$length")"
    echo "$result"
}
export -f string_contains
export -f string_multiline_contains
export -f string_to_uppercase
export -f string_strip_prefix
export -f string_strip_suffix
export -f string_is_empty_or_null
export -f string_colorify
export -f string_blue
export -f string_yellow
export -f string_green
export -f string_red
export -f assert_not_empty
export -f unique_id 
function log() {
    local -r level="$1"
    local -r message="$2"
    local -r timestamp=$(date +"%Y-%m-%d %H:%M:%S")
    local -r script_name="$(basename "$0")"
    local color
    case "$level" in
    INFO)
        color="string_green"
        ;;
    WARN)
        color="string_yellow"
        ;;
    ERROR)
        color="string_red"
        ;;
    esac
    # echo >&2 -e "$(string_colorify "${color}" "${timestamp} [${level}] ==>") $(string_blue "[$script_name]") ${message}"
    echo >&2 -e "$(${color} "${timestamp} [${level}] ==>") $(string_blue "[$script_name]") ${message}"
}
function log_info() {
    local -r message="$1"
    log "INFO" "$message"
}
function log_warn() {
    local -r message="$1"
    log "WARN" "$message"
}
function log_error() {
    local -r message="$1"
    log "ERROR" "$message"
}
export -f log
export -f log_info
export -f log_warn
export -f log_error 
function array_contains() {
    local -r needle="$1"
    shift
    local -ra haystack=("$@")
    local item
    for item in "${haystack[@]}"; do
        if [[ "$item" == "$needle" ]]; then
            return 0
        fi
    done
    return 1
}
# https://stackoverflow.com/a/15988793/2308858
function array_split() {
    local -r separator="$1"
    local -r str="$2"
    local -a ary=()
    IFS="$separator" read -ra ary <<<"$str"
    # echo "${ary[*]}"
    echo "${ary[@]}"
}
function array_join() {
    local -r separator="$1"
    shift
    local -ar values=("$@")
    local out=""
    for ((i = 0; i < "${#values[@]}"; i++)); do
        if [[ "$i" -gt 0 ]]; then
            out="${out}${separator}"
        fi
        out="${out}${values[i]}"
    done
    echo -n "$out"
}
# https://stackoverflow.com/a/13216833/2308858
function array_prepend() {
    local -r prefix="$1"
    shift 1
    local -ar ary=("$@")
    updated_ary=("${ary[@]/#/$prefix}")
    echo "${updated_ary[*]}"
}
export -f array_contains
export -f array_split
export -f array_join
export -f array_prepend 
function array_contains() {
    local -r needle="$1"
    shift
    local -ra haystack=("$@")
    local item
    for item in "${haystack[@]}"; do
        if [[ "$item" == "$needle" ]]; then
            return 0
        fi
    done
    return 1
}
# https://stackoverflow.com/a/15988793/2308858
function array_split() {
    local -r separator="$1"
    local -r str="$2"
    local -a ary=()
    IFS="$separator" read -ra ary <<<"$str"
    # echo "${ary[*]}"
    echo "${ary[@]}"
}
function array_join() {
    local -r separator="$1"
    shift
    local -ar values=("$@")
    local out=""
    for ((i = 0; i < "${#values[@]}"; i++)); do
        if [[ "$i" -gt 0 ]]; then
            out="${out}${separator}"
        fi
        out="${out}${values[i]}"
    done
    echo -n "$out"
}
# https://stackoverflow.com/a/13216833/2308858
function array_prepend() {
    local -r prefix="$1"
    shift 1
    local -ar ary=("$@")
    updated_ary=("${ary[@]/#/$prefix}")
    echo "${updated_ary[*]}"
}
export -f array_contains
export -f array_split
export -f array_join
export -f array_prepend 
function file_exists() {
    local -r file="$1"
    [[ -f "$file" ]]
}
function get_file_name() {
    local -r target="$1"
    echo "${target##*/}"
}
function get_file_dir() {
    local -r target="$1"
    echo "${target%/*}"
}
function file_exists() {
    local -r file="$1"
    [[ -f "$file" ]]
}
function append_line_to_file() {
    if [[ $# != 2 ]]; then
        echo
        echo "desc : adds a line to a file in case it hasn't already been added "
        echo
        echo "method usage: append_line_to_file [target file] [line]"
        echo
        exit 1
    fi
    local -r dest="$1"
    local -r payload="$2"
    assert_not_empty "file path" "$dest" "needs a file path to work"
    assert_not_empty "line " "$payload" "needs a line to append to file"
    if [[ -z $(grep "$payload" "$dest") ]]; then
        echo "$payload" >>"$dest"
    fi
}
function add_to_bashrc() {
    if [[ $# != 1 ]]; then
        echo
        echo "desc : appends a line to .bashrc in case it hasn't been already added "
        echo
        echo "method usage: add_to_bashrc [line]"
        echo
        exit 1
    fi
    source "$HOME/.bashrc"
    local payload="$1"
    log_info "adding $payload to '$HOME/.bashrc'"
    append_line_to_file "$HOME/.bashrc" "$payload"
    source "$HOME/.bashrc"
}
function add_profile_env_var() {
    if [[ $# != 2 ]]; then
        echo
        echo "desc : adds and exports a variable to .bashrc "
        echo
        echo "method usage: add_profile_env_var [variable name] [variable value]"
        echo
        exit 1
    fi
    local key="$1"
    local value="$2"
    add_to_bashrc "export $key=$value"
}
function add_to_path() {
    if [[ $# != 1 ]]; then
        echo
        echo "desc : adds a directory to path in case it hasn't been already added "
        echo
        echo "method usage: add_to_path [target directory]"
        echo
        exit 1
    fi
    local target_dir="$1"
    add_profile_env_var "PATH" '$PATH':"$target_dir"
}
function downloader() {
    if [[ $# != 1 ]]; then
        echo
        echo "desc : uses aria2 to download links in a file "
        echo
        echo "method usage: downloader [file path containing links]"
        echo
        exit 1
    fi
    local download_list="$1"
    local downloader=""
    downloader="aria2c \
            -j 16 \
            --continue=true \
            --max-connection-per-server=16 \
            --optimize-concurrent-downloads \
            --connect-timeout=600 \
            --timeout=600 \
            --min-split-size=1M \
            --input-file=$download_list"
    $downloader
}
export -f file_exists
export -f get_file_name
export -f get_file_dir
export -f file_exists
export -f append_line_to_file
export -f add_to_bashrc
export -f add_profile_env_var
export -f add_to_path
export -f downloader 
function is_root() {
    [ "$EUID" == 0 ]
}
function os_command_is_available() {
    local name
    name="$1"
    command -v "$name" >/dev/null
}
function has_sudo() {
    os_command_is_available "sudo"
}
function has_apt() {
    os_command_is_available "apt-get"
}
function has_parallel() {
    os_command_is_available "parallel"
}
function is_pkg_installed() {
    local -r pkg="$1"
    dpkg -s "$pkg" 2>/dev/null | grep ^Status | grep -q installed
}
function confirm_sudo() {
    # if ! is_root; then
    #     log_error "needs root permission to run.exiting..."
    #     exit 1
    # fi
    local target="sudo"
    if ! is_pkg_installed "apt-utils"; then
        log_info "apt-utils is not available ... installing now"
        apt-get -qq update &&
            DEBIAN_FRONTEND=noninteractive apt-get install -qqy apt-utils
    fi
    if ! has_sudo; then
        log_info "sudo is not available ... installing now"
        apt-get -qq update &&
            DEBIAN_FRONTEND=noninteractive apt-get install -qqy "$target"
    fi
}
function arch_probe(){
    echo $(uname -m)
}
function os_name(){
    echo "$(uname -s | tr "[:upper:]" "[:lower:]")" 
}
function min_bash_version() {
    local -r ver="$1"
	[ "${BASH_VERSINFO:-0}" -ge $((ver)) ]
}
function get_debian_codename() {
    local -r os_release=$(cat /etc/os-release)
    local -r version_codename_line=$(echo "$os_release" | grep -e VERSION_CODENAME)
    local -r result=$(string_strip_prefix "$version_codename_line" "VERSION_CODENAME=")
    echo "$result"
}
function get_distro_name() {
    local -r os_release=$(cat /etc/os-release)
    local -r trimmed=$(echo "$os_release" | grep -v VERSION_ID | grep -v ID_LIKE)
    local -r version_codename_line=$(echo "$trimmed" | grep -e ID)
    local -r result=$(string_strip_prefix "$version_codename_line" "ID=")
    echo "$result"
}
function add_key() {
    if ! is_root; then
        log_error "needs root permission to run.exiting..."
        exit 1
    fi
    if [[ $# == 0 ]]; then
        log_error "No argument was passed to add_key method"
        exit 1
    fi
    curl -fsSL "$1" | sudo apt-key add -
}
function add_repo() {
    if ! is_root; then
        log_error "needs root permission to run.exiting..."
        exit 1
    fi
    if [[ $# != 2 ]]; then
        echo
        echo "desc : adds an apt repository"
        echo
        echo "method usage: add_repo [name] [address]"
        echo
        exit 1
    fi
    local -r dest="/etc/apt/sources.list.d/$1.list"
    local -r addr="$2"
    if file_exists "$dest"; then
        log_warn "a repo source for $1 already exists. deleting the existing one..."
        rm "$dest"
    fi
    log_info "adding repo for $1"
    echo "$addr" | sudo tee "$dest"
    sudo apt-get update
}
function apt_cleanup() {
    if ! is_root; then
        log_error "needs root permission to run.exiting..."
        exit 1
    fi
    confirm_sudo
    local -r download_list="/tmp/apt-fast.list"
    if file_exists "$download_list"; then
        sudo apt-get install -y --fix-broken
        rm "$download_list"
    fi
    sudo apt-get clean
    sudo rm -rf /var/cache/apt/archives/*
}
function filter_installed() {
    local -r deps=("$@")
    local -r raw_list=$(dpkg -s ${deps[@]} 2>&1)
    local -r filtered=$(echo "${raw_list}" | grep -E "dpkg-query: package")
    local -r trimmed=$(echo "${filtered}" | sed -n "s,[^']*'\([^']*\).*,\1,p")
    echo "$trimmed"
}
function assert_is_installed() {
    local -r name="$1"
    if ! os_command_is_available "$name"; then
        log_error "'$name' is required but cannot be found in the system's PATH."
        exit 1
    fi
}
function user_exists() {
    local -r user="$1"
    getent passwd ${user}  > /dev/null
}
function new_user_as_sudo() {
    if ! is_root; then
        log_error "needs root permission to run.exiting..."
        exit 1
    fi
    if [[ $# == 0 ]]; then
        log_error "No argument was passed to new_user_as_sudo method"
        exit 1
    fi
    local -r user="$1"
    if ! $(user_exists "${user}");then
        log_info "creating user ${user}"
        sudo useradd -l -u 33333 -G sudo \
        -md "/home/${user}" \
        -s  /bin/bash -p "${user}" "${user}" 
    fi
}
function execute_as_sudo {
        local firstArg=$1
        if [ $(type -t $firstArg) = function ]
        then
                shift && command sudo bash -c "$(declare -f $firstArg);$firstArg $*"
        elif [ $(type -t $firstArg) = alias ]
        then
                alias sudo='\sudo '
                eval "sudo $@"
        else
                command sudo "$@"
        fi
}
export -f is_root
export -f os_command_is_available
export -f has_sudo
export -f has_apt
export -f has_parallel
export -f is_pkg_installed
export -f confirm_sudo
export -f get_debian_codename
export -f add_key
export -f add_repo
export -f apt_cleanup
export -f filter_installed
export -f assert_is_installed
export -f min_bash_version
export -f arch_probe
export -f user_exists
export -f new_user_as_sudo
export -f os_name
export -f get_distro_name
export -f execute_as_sudo 
# "extract <file> [path]" "extract any given archive"
function extract() {
    if ! os_command_is_available "unzip"; then
        log_error "unzip is not available. existing..."
        exit 1
    fi
    if [[ -f "$1" ]]; then
        if [[ "$2" == "" ]]; then
            case "$1" in
            *.rar)
                rar x "$1" "${1%.rar}"/
                if ! os_command_is_available "rar"; then
                    log_error "rar is not available. existing..."
                    exit 1
                fi
                ;;
            *.tar.bz2) mkdir -p "${1%.tar.bz2}" && tar xjf "$1" -C "${1%.tar.bz2}"/ ;;
            *.tar.gz) mkdir -p "${1%.tar.gz}" && tar xzf "$1" -C "${1%.tar.gz}"/ ;;
            *.tar.xz) mkdir -p "${1%.tar.xz}" && tar xf "$1" -C "${1%.tar.xz}"/ ;;
            *.tar) mkdir -p "${1%.tar}" && tar xf "$1" -C "${1%.tar}"/ ;;
            *.tbz2) mkdir -p "${1%.tbz2}" && tar xjf "$1" -C "${1%.tbz2}"/ ;;
            *.tgz) mkdir -p "${1%.tgz}" && tar xzf "$1" -C "${1%.tgz}"/ ;;
            *.zip)
                if ! os_command_is_available "unzip"; then
                    log_error "unzip is not available. existing..."
                    exit 1
                fi
                unzip -oq "$1" -d "${1%.zip}"/
                ;;
            # *.zip) unzip "$1" -d "${1%.zip}"/ ;;
            *.7z) 7za e "$1" -o"${1%.7z}"/ ;;
            *) log_error "$1 cannot be extracted." ;;
            esac
        else
            case "$1" in
            *.rar)
                if ! os_command_is_available "rar"; then
                    log_error "rar is not available. existing..."
                    exit 1
                fi
                rar x "$1" "$2"
                ;;
            *.tar.bz2) mkdir -p "$2" && tar xjf "$1" -C "$2" ;;
            *.tar.gz) mkdir -p "$2" && tar xzf "$1" -C "$2" ;;
            *.tar.xz) mkdir -p "$2" && tar xf "$1" -C "$2" ;;
            *.tar) mkdir -p "$2" && tar xf "$1" -C "$2" ;;
            *.tbz2) mkdir -p "$2" && tar xjf "$1" -C "$2" ;;
            *.tgz) mkdir -p "$2" && tar xzf "$1" -C "$2" ;;
            *.zip)
                if ! os_command_is_available "unzip"; then
                    log_error "unzip is not available. existing..."
                    exit 1
                fi
                unzip -oq "$1" -d "$2"
                ;;
            # *.zip) unzip "$1" -d "$2" ;;
            *.7z) 7z e "$1" -o"$2"/ ;;
            *) log_error "$1 cannot be extracted." ;;
            esac
        fi
    else
        log_error "$1 cannot be extracted."
    fi
}
export -f extract 
# package functions
function is_git_available() {
    if ! os_command_is_available "git"; then
        log_error "git is not available. existing..."
        exit 1
    fi
}
function git_undo_commit() {
    is_git_available
    git reset --soft HEAD~
}
function git_reset_local() {
    is_git_available
    git fetch origin
    git reset --hard origin/master
}
function git_pull_latest() {
    is_git_available
    git pull --rebase origin master
}
function git_list_branches() {
    is_git_available
    git branch -a
}
function git_new_branch() {
    is_git_available
    if [[ $# == 1 ]]; then
        echo
        echo "desc : creates a new branch"
        echo
        echo "method usage: git_new_branch <branch name>"
        echo
        exit 1
    fi
    local -r name="$1"
    assert_not_empty "name" "$name" "branch name is needed"
    git checkout -b "$name"
}
function git_repo_size() {
    is_git_available
    # do not show output of git bundle create {>/dev/null 2>&1} ...
    git bundle create .tmp-git-bundle --all >/dev/null 2>&1
    # check for existance of du
    if ! os_command_is_available "du"; then
        log_error "du is not available. existing..."
        exit 1
    fi
    local -r size=$(du -sh .tmp-git-bundle | cut -f1)
    rm .tmp-git-bundle
    echo "$size"
}
function git_user_stats() {
    if [[ $# == 1 ]]; then
        echo
        echo "desc : returns users contributions"
        echo
        echo "method usage: git_user_stats <user name>"
        echo
        exit 1
    fi
    local -r user_name="$1"
    assert_not_empty "user_name" "$user_name" "git username is needed"
    res=$(git log --author="$user_name" --pretty=tformat: --numstat | awk -v GREEN='033[1;32m' -v PLAIN='033[0m' -v RED='033[1;31m' 'BEGIN { add = 0; subs = 0 } { add += $1; subs += $2 } END { printf "Total: %s+%s%s / %s-%s%sn", GREEN, add, PLAIN, RED, subs, PLAIN }')
    echo "$res"
}
function git_clone() {
    is_git_available
    if [[ $# == 0 ]]; then
        echo
        echo "desc : clones and extracts a reposiory lists with aria2"
        echo
        echo "method usage: git_new_branch <branch name>"
        echo
        exit 1
    fi
    local -r repos=("$@")
    local -r download_list="/tmp/git-dl.list"
    if file_exists "${download_list}"; then
        log_warn "existing git candidate download list detected.deleting..."
        rm "$download_list"
    fi
    for repo in "${repos[@]}"; do
        assert_not_empty "repo" "$repo" "repo url cannot be empty"
        name=$(get_file_name "$repo")
        if file_exists "$PWD/$name.zip"; then
            log_warn "an exisitng clone of repositry archive exists.deleting..."
            rm "$PWD/$name.zip"
        fi
        log_info "cloning $repo"
        local -r url="$repo/archive/master.zip"
        echo "${url}" >>"${download_list}"
        echo " dir=$PWD" >>"${download_list}"
        echo " out=$name.zip" >>"${download_list}"
    done
    if file_exists "${download_list}"; then
        downloader "$download_list"
    fi
    for repo in "${repos[@]}"; do
        name=$(get_file_name "$repo")
        if file_exists "$PWD/$name.zip"; then
            extract "$PWD/$name.zip" "$name"
            mv "$PWD/$name/$name-master" "$PWD"
            rm -rf "$PWD/$name/"
            mv "$PWD/$name-master/" "$PWD/$name/"
            rm "$PWD/$name.zip"
        fi
    done
}
function git_release_list() {
    if [[ $# != 2 ]]; then
        echo
        echo "desc : get a repo's releases from"
        echo
        echo "method usage: get_releases_from_git [repo owner] [repo name]"
        echo
        exit 1
    fi
    local -r owner="$1"
    local -r repo="$2"
    local -r reply=$(curl -sL "https://api.github.com/repos/${owner}/${repo}/tags")
    local -r versions=$(echo "${reply}" | jq -r '.[].name')
    local -r sorted=$(echo "${versions}" | sort -t. -k 1,1n -k 2,2n -k 3,3n -k 4,4n)
    local -r trimmed=$(echo "${sorted}" | grep -v -E 'beta|master|pre|rc|test')
    echo "$trimmed"
}
function get_latest_release_from_git() {
    if [[ $# != 2 ]]; then
        echo
        echo "desc : gets latest release from git"
        echo
        echo "method usage: get_latest_release_from_git [repo owner] [repo name]"
        echo
        exit 1
    fi
    local -r repo_owner="$1"
    local -r repo_name="$2"
    local -r reply=$(curl -sL https://api.github.com/repos/${repo_owner}/${repo_name}/releases/latest)
    local -r latest=$(echo "$reply" | jq -r '.tag_name')
    echo "$latest"
}
export -f get_latest_release_from_git
export -f is_git_available
export -f git_undo_commit
export -f git_reset_local
export -f git_pull_latest
export -f git_list_branches
export -f git_new_branch
export -f git_repo_size
export -f git_user_stats
export -f git_clone
export -f git_release_list 
function fast_apt() {
    # [ "$(whoami)" = root ] || exec sudo "$0" "$@"
    if echo "$@" | grep -q "upgrade\|install\|dist-upgrade"; then
        local -r download_list="/tmp/apt-fast.list"
        local -r apt_cache="/var/cache/apt/archives"
        local -r command="${1}"
        shift
        local -r uris=$(apt-get -y --print-uris $command "${@}")
        local -r urls=($(echo ${uris} | grep -o -E "(ht|f)t(p|ps)://[^\']+" ))
        for link in ${urls[@]}; do
            log_info "adding ${link} to download candidates"
            echo "$link" >>"$download_list"
            echo " dir=$apt_cache" >>"$download_list"
        done
        if  file_exists "$download_list"; then
            downloader "$download_list"
            sudo apt-get $command -y "$@" 
            log_info "cleaning up apt cache ..."
            apt_cleanup
        else
            log_warn "there are no install candidates at $download_list "
            log_info "cleaning up apt cache ..."
            apt_cleanup
        fi
    else
        sudo apt-get "$@"
    fi
}
export -f fast_apt
function init() {
    confirm_sudo
    # [ "$(whoami)" = root ] || exec sudo "$0" "$@"
    if ! os_command_is_available "aria2c"; then
        log_info "aria2 not available.installing aria2 ..."
        sudo apt-get install -yqq aria2
    fi
    if ! os_command_is_available "curl"; then
        log_info "curl not available.installing curl ..."
        sudo apt-get install -yqq curl
    fi
    if ! os_command_is_available "netselect-apt"; then
        log_info "netselect-apt not available.installing netselect-apt ..."
        if ! os_command_is_available "wget"; then
            log_info "wget not available.installing wget ..."
            sudo apt-get install -yqq wget
        fi
        sudo apt-get install -y --fix-broken
        pushd "/tmp/" >/dev/null 2>&1
        rm -rf netselect*
        echo "http://ftp.us.debian.org/debian/pool/main/n/netselect/netselect_0.3.ds1-28+b1_amd64.deb" >>/tmp/netselect.list
        echo "http://ftp.us.debian.org/debian/pool/main/n/netselect/netselect-apt_0.3.ds1-28_all.deb" >>/tmp/netselect.list
        local -r netselect_links="/tmp/netselect.list"
        downloader "$netselect_links"
        sudo dpkg -i netselect_0.3.ds1-28+b1_amd64.deb
        sudo dpkg -i netselect-apt_0.3.ds1-28_all.deb
        rm -rf netselect*
        [[ "$?" != 0 ]] && popd
        popd >/dev/null 2>&1
    fi
    if ! file_exists "/etc/apt/sources-fast.list"; then
        log_warn "fast apt sources have not been added. adding now ..."
        sudo netselect-apt \
            --tests 15 \
            --sources \
            --nonfree \
            --outfile /etc/apt/sources-fast.list \
            stable
        sudo apt-get update
    fi
      packages=("git" 
        "apt-utils" 
        "unzip" 
        "build-essential" 
        "software-properties-common"
        "make" 
        "vim" 
        "nano" 
        "ca-certificates"
        "wget" 
        "jq" 
        "apt-transport-https" 
        "parallel"
        "gcc"
        "g++"
        "ufw"
        "progress"
        "bzip2"
        "tmux"
        "zip")
    fast_apt "install" "${packages[@]}"
    if has_parallel; then
        log_info "parallelizing env ..."
        env_parallel --install
    fi
}
export -f init
bash_version="4"
if ! min_bash_version "$bash_version"; then
    log_error "you bash version is ${BASH_VERSINFO}.Minimum supported version is $bash_version"
    exit 1
fi 
# end of shared base
function node_installer() {
    if ! is_root; then
        log_error "needs root permission to run.exiting..."
        exit 1
    fi
    confirm_sudo
    [ "$(whoami)" = root ] || exec sudo "$0" "$@"
    # script specific packages
    if ! os_command_is_available "yarn"; then
        log_info "running NodeSource Node.js 12.x installer script"
        curl -fsSL https://deb.nodesource.com/setup_12.x | sudo bash -
    fi    
    if ! os_command_is_available "npm"; then
        log_info "adding yarn apt repo key"
        add_key "https://dl.yarnpkg.com/debian/pubkey.gpg"
        add_repo "yarn-nightly" "deb https://nightly.yarnpkg.com/debian/ nightly main"
    fi
    packages=("nodejs" "yarn")
    fast_apt "install" "${packages[@]}"
    if os_command_is_available "yarn"; then
        log_info "yarn has been installed.fixing environment vars"
        add_to_path '`yarn global bin`'
        add_to_path '${HOME}/.yarn/bin'
    fi
}
export -f node_installer 
function ffmpeg_installer() {
    if ! is_root; then
        log_error "needs root permission to run.exiting..."
        exit 1
    fi
    confirm_sudo
    [ "$(whoami)" = root ] || exec sudo "$0" "$@"
    if ! is_pkg_installed "mkvtoolnix"; then
        log_warn "mkvtoolnix not found"
        log_info "adding mkvtoolnix apt repo key"
        add_key "https://mkvtoolnix.download/gpg-pub-moritzbunkus.txt"
        add_repo "mkvtoolnix" "deb https://mkvtoolnix.download/$(get_distro_name)/ $(get_debian_codename) main"
    fi
    local -r packages=("mkvtoolnix" "ffmpeg")
    fast_apt "install" "${packages[@]}"
    if os_command_is_available "npm"; then
        if ! os_command_is_available "ffmpeg-bar"; then
            log_info "install ffmpeg-progress-bar ..."
            npm install --global ffmpeg-progressbar-cli
        else
            log_info "ffmpeg-progress-bar already installed.skipping ..."
        fi
    fi
}
export -f ffmpeg_installer 
function docker_installer() {
    if ! is_root; then
        log_error "needs root permission to run.exiting..."
        exit 1
    fi
    if [[ $# == 0 ]]; then
        log_error "No argument was passed to go_installer"
        exit 1
    fi
    local -r user="$1"
    local home="/home/$user"
    confirm_sudo
    local compose_version=$(get_latest_release_from_git "docker" "compose") 
    if [[ $# == 2 ]]; then
        compose_version="$2"
    fi
    log_info "started procedure for docker/docker-compose"
    log_info "adding docker apt repo key"
    if ! os_command_is_available "docker"; then
        add_key "https://download.docker.com/linux/$(get_distro_name)/gpg"
        add_repo "docker" "deb [arch=amd64] https://download.docker.com/linux/$(get_distro_name) $(get_debian_codename) stable"
    fi    
    local -r packages=("docker-ce" "docker-ce-cli" "containerd.io")
    fast_apt "install" "${packages[@]}"
    if os_command_is_available "docker"; then
        if [[  -n "${home+x}" ]]; then
            log_info "making docker directories"
            mkdir -p "$home/.docker"
            mkdir -p "$home/.local/share/applications/"
            mkdir -p "$home/.local/bin"
        fi
        if [[  -n "${user+x}" ]]; then
            log_info "adding docker image and transferring setting docker folder permission to ${user}"
            sudo newgrp docker
            sudo usermod -aG docker "$user"
            sudo chown "$user":"$user" "/$home/.docker" -R
            sudo chmod g+rwx "$home/.docker" -R
        fi
        if os_command_is_available "systemctl"; then
            log_info "enabling docker service"
            systemctl enable docker
        fi
    fi
    local -r url="https://github.com/docker/compose/releases/download/"$compose_version"/docker-compose-$(uname -s)-$(uname -m)"
    local -r compose_path="/usr/local/bin/docker-compose"
    log_info "installing docker-compose version $compose_version for ${user} with url $url"
    sudo curl \
        -L "$url" \
        -o "$compose_path" && \
    sudo chmod +x "$compose_path"
}
export -f docker_installer 
function get_go_latest_version() {
    local -r reply=$(curl -sL https://golang.org/dl/?mode=json)
    local -r versions=$(echo "$reply" | jq -r '.[].version')
    local -r sorted=$(echo "$versions" | sort -t. -k 1,1n -k 2,2n -k 3,3n -k 4,4n)
    local -r trimmed=$(echo "$sorted" | egrep -v 'beta')
    local -r latest=$(echo "$trimmed" | tail -1)
    echo "$(string_strip_prefix "$latest" "go")"
}
function go_installer() {
    if ! is_root; then
        log_error "needs root permission to run.exiting..."
        exit 1
    fi
    if [[ $# == 0 ]]; then
        log_error "No argument was passed to go_installer"
        exit 1
    fi
    local -r user="$1"
    local home="/home/$user"
    confirm_sudo
    if is_pkg_installed "golang-go"; then
        log_warn "golang-go is installed, removing..."
        sudo apt-get remove -yqq golang-go
    fi
    local arch
    arch=$(arch_probe)
    case "$arch" in
        i*)
            arch="386"
        ;;
        x*)
            arch="amd64"
        ;;
        aarch64)
            arch="armv6l"
        ;;
        armv7l)
            arch="armv6l"
        ;;
    esac
    local -r os=$(os_name)
    local -r uuid=$(unique_id 6)
    local version
    version=$(get_go_latest_version)
    if [[ $# == 2 ]]; then
        version="$2"
    fi
    local -r download_dir="/tmp/go_tmp_${uuid}"
    local -r root_dir="/usr/local"
    local -r file_name="go${version}.${os}-${arch}.tar.gz"
    local -r url="https://storage.googleapis.com/golang/${file_name}"
    log_info "installing go ${version} arch ${arch} for user ${user}"
    mkdir -p "${download_dir}"
    local -r go_archive="${download_dir}/${file_name}"
    local -r download_list="/tmp/go-lang.list"
    rm -f "${download_list}"
    log_info "about to download go version ${version} for os ${os} and arch ${arch}"
    if file_exists "$go_archive"; then
        log_warn "$go_archive has already been downloaded. deleting the existing one..."
        rm "$go_archive"
    fi
    echo "${url}" >>"${download_list}"
    echo " dir=${download_dir}" >>"${download_list}"
    echo " out=${file_name}" >>"${download_list}"
    if file_exists "${download_list}"; then
        downloader "$download_list"
    fi
    local -r go_root="${root_dir}/go"
    log_info "removing any existing installations at $go_root"
    sudo rm -rf "$go_root" 
    log_info "extracting ${go_archive} into ${go_root}"
    extract "${go_archive}" "${root_dir}"
    local -r go_tool_dir="${go_root}/bin"
    # testing installation
    log_info "testing extracted go tool "
    "$go_tool_dir/go" version
    # creating go folders
    log_info "creating GOPATH folders at \$HOME/go/bin \$HOME/go/pkg \$HOME/go/src"
    log_info "making go dirs at ${home}"
    mkdir -p "${home}/go/bin"
    mkdir -p "${home}/go/src"
    mkdir -p "${home}/go/pkg"
    log_info "setting ownership of go dirs to ${user}"
    sudo chown "${user}":"${user}" "${home}/go" -R
    sudo chmod g+rwx "${home}/go" -R
    # adding go to path
    log_info "adding GO env variables to \$HOME/.bashrc"
    add_profile_env_var "GOPATH" '$HOME/go'
    add_profile_env_var "GOROOT" "${go_root}"
    add_profile_env_var "GO111MODULE" 'off'
    add_to_path '$GOROOT/bin:$GOPATH/bin'
    # testing path
    log_info "making sure go was successfully added to path"
    go version
    log_info "cleaning up ${go_archive}"
    rm -rf "${go_archive}"
    rm -f "${download_list}"
}
export -f go_installer
export -f get_go_latest_version 
function cpp_installer() {
    if ! is_root; then
        log_error "needs root permission to run.exiting..."
        exit 1
    fi
    confirm_sudo
    [ "`whoami`" = root ] || exec sudo "$0" "$@"
    log_info "started procedure for llvm/cpp/c toolchains"
    log_info "adding llvm apt repo key"
    add_key "https://apt.llvm.org/llvm-snapshot.gpg.key"
    add_repo "llvm" "deb http://apt.llvm.org/$(get_debian_codename)/ llvm-toolchain-$(get_debian_codename) main"
    # @todo add clang-tools 
    # breaks gp build atm
    local -r packages=("g++" "gcc" "clang-format" "clang-tidy" "clangd" "gdb" "lld")
    fast_apt "install" "${packages[@]}"
}
export -f cpp_installer 
function vscode_installer() {
    if  os_command_is_available "code"; then
        log_warn "vscode has already been installed...skipping installation." 
        exit 0
    fi
    log_info "started procedure for installing vscode"
    log_info "adding vscode apt repo key"
    add_key "https://packages.microsoft.com/keys/microsoft.asc"
    add_repo "vscode" "deb [arch=amd64] https://packages.microsoft.com/repos/vscode stable main"
    local -r packages="code"
    fast_apt "install" "${packages[@]}"
}
export -f vscode_installer
function vscode_extension_installer() {
    if  !os_command_is_available "code"; then
        log_error "vscode_extension_installer cannot proceed forward since code was not found in path."
        exit 1
    fi    
    if  os_command_is_available "go"; then
        log_info "go toolchain detected... installing vscode golang tools"
        go get -u -v github.com/ramya-rao-a/go-outline
        go get -u -v github.com/acroca/go-symbols
        go get -u -v github.com/mdempsky/gocode
        go get -u -v github.com/rogpeppe/godef
        go get -u -v golang.org/x/tools/cmd/godoc
        go get -u -v github.com/zmb3/gogetdoc
        go get -u -v golang.org/x/lint/golint
        go get -u -v github.com/fatih/gomodifytags
        go get -u -v golang.org/x/tools/cmd/gorename
        go get -u -v sourcegraph.com/sqs/goreturns
        go get -u -v golang.org/x/tools/cmd/goimports
        go get -u -v github.com/cweill/gotests/...
        go get -u -v golang.org/x/tools/cmd/guru
        go get -u -v github.com/josharian/impl
        go get -u -v github.com/haya14busa/goplay/cmd/goplay
        go get -u -v github.com/uudashr/gopkgs/cmd/gopkgs
        go get -u -v github.com/davidrjenni/reftools/cmd/fillstruct
        go get -u -v github.com/alecthomas/gometalinter
        gometalinter --install
        go get -u -v github.com/cuonglm/gocmt
        go get -u -v honnef.co/go/tools/cmd/staticcheck
        pushd "${GOPATH}/src/honnef.co/go/tools/cmd/staticcheck" >/dev/null 2>&1
            git checkout 2019.2
            go get
            go install
        [[ "$?" != 0 ]] && popd
        popd >/dev/null 2>&1
    fi
    log_info "installing some helpful vscode extensions"
    code --install-extension esbenp.prettier-vscode
    code --install-extension ms-azuretools.vscode-docker
    code --install-extension ms-python.anaconda-extension-pack
    code --install-extension ms-python.python
    code --install-extension ms-vscode-remote.remote-containers
    code --install-extension ms-vscode-remote.remote-ssh
    code --install-extension ms-vscode-remote.remote-ssh-edit
    code --install-extension ms-vscode-remote.remote-wsl
    code --install-extension ms-vscode-remote.vscode-remote-extensionpack
    code --install-extension ms-vscode.Go
    code --install-extension puorc.awesome-vhdl
    code --install-extension redhat.vscode-yaml
    code --install-extension ripwu.protobuf-helper
    code --install-extension Vinrobot.vhdl-formatter
    code --install-extension wholroyd.HCL
    code --install-extension xaver.clang-format
    code --install-extension zxh404.vscode-proto3
    code --install-extension yzane.markdown-pdf
    code --install-extension yzhang.markdown-all-in-one
    code --install-extension wmaurer.change-case
    code --install-extension alefragnani.Bookmarks
}
export -f vscode_extension_installer 
function java_installer() {
    # [ "`whoami`" = root ] || exec sudo "$0" "$@"
    log_info "started procedure for java"
    log_info "downloading sdkman script"
    curl -fsSL "https://get.sdkman.io" | bash 
    log_info "running sdkman init script"
    chmod +x ${HOME}/.sdkman/bin/sdkman-init.sh
    source ${HOME}/.sdkman/bin/sdkman-init.sh 
    sdk install java 11.0.6.hs-adpt 
    log_info "installing gradle"
    sdk install gradle 
    log_info "installing maven"
    sdk install maven 
    log_info "cleaning up"
    sdk flush archives 
    sdk flush temp 
    log_info "storing setting at ${HOME}/.m2/settings.xml "
    mkdir -p $HOME/.m2 
    printf '<settings>\n  <localRepository>/workspace/m2-repository/</localRepository>\n</settings>\n' > $HOME/.m2/settings.xml
    add_to_bashrc '[[ -s \"$HOME/.sdkman/bin/sdkman-init.sh\" ]] && source \"$HOME/.sdkman/bin/sdkman-init.sh\"'
    add_profile_env_var "SDKMAN_DIR" '${HOME}/.sdkman/'
    mkdir -p ${HOME}/.gradle/
    add_profile_env_var "GRADLE_USER_HOME" '${HOME}/.gradle/'
} 
function docker_installer() {
    if ! is_root; then
        log_error "needs root permission to run.exiting..."
        exit 1
    fi
    if [[ $# == 0 ]]; then
        log_error "No argument was passed to go_installer"
        exit 1
    fi
    local -r user="$1"
    local home="/home/$user"
    confirm_sudo
    local compose_version=$(get_latest_release_from_git "docker" "compose") 
    if [[ $# == 2 ]]; then
        compose_version="$2"
    fi
    log_info "started procedure for docker/docker-compose"
    log_info "adding docker apt repo key"
    if ! os_command_is_available "docker"; then
        add_key "https://download.docker.com/linux/$(get_distro_name)/gpg"
        add_repo "docker" "deb [arch=amd64] https://download.docker.com/linux/$(get_distro_name) $(get_debian_codename) stable"
    fi    
    local -r packages=("docker-ce" "docker-ce-cli" "containerd.io")
    fast_apt "install" "${packages[@]}"
    if os_command_is_available "docker"; then
        if [[  -n "${home+x}" ]]; then
            log_info "making docker directories"
            mkdir -p "$home/.docker"
            mkdir -p "$home/.local/share/applications/"
            mkdir -p "$home/.local/bin"
        fi
        if [[  -n "${user+x}" ]]; then
            log_info "adding docker image and transferring setting docker folder permission to ${user}"
            sudo newgrp docker
            sudo usermod -aG docker "$user"
            sudo chown "$user":"$user" "/$home/.docker" -R
            sudo chmod g+rwx "$home/.docker" -R
        fi
        if os_command_is_available "systemctl"; then
            log_info "enabling docker service"
            systemctl enable docker
        fi
    fi
    local -r url="https://github.com/docker/compose/releases/download/"$compose_version"/docker-compose-$(uname -s)-$(uname -m)"
    local -r compose_path="/usr/local/bin/docker-compose"
    log_info "installing docker-compose version $compose_version for ${user} with url $url"
    sudo curl \
        -L "$url" \
        -o "$compose_path" && \
    sudo chmod +x "$compose_path"
}
export -f docker_installer 
function get_hashi_latest_version() {
    if [[ $# != 1 ]]; then
        echo
        echo "desc : gets latest version of a hashicorp software"
        echo
        echo "method usage: get_hashi_latest_version [software name]"
        echo
        exit 1
    fi
    assert_not_empty "get_hashi_latest_version" "$1" "user input is needed"
    local -r reply=$(curl -sL "https://releases.hashicorp.com/${1}/index.json")
    local -r versions=$(echo "$reply" | jq -r '.versions[].version')
    local -r sorted=$(echo "$versions" | sort -t. -k 1,1n -k 2,2n -k 3,3n -k 4,4n)
    local -r trimmed=$(echo "$sorted" | grep -E -v 'ent|rc|beta')
    local -r latest=$(echo "$trimmed" | tail -1)
    echo "$latest"
}
function get_hashi() {
    if [[ $# == 0 ]]; then
        echo
        echo "desc : downloads and installs lastes hashicorp software"
        echo
        echo "method usage: get_hashi [list of software name]"
        echo
        exit 1
    fi
    [ "$(whoami)" = root ] || exec sudo "$0" "$@"
    local -r packages=("$@")
    local -r download_list="/tmp/hashistack.list"
    rm -f "${download_list}"
    mkdir -p "/tmp/get-hashi/"
    for name in "${packages[@]}"; do
        log_info "adding ${name}"
        rm -rf "/tmp/get-hashi/${name}"*
        local version
        local url
        version=$(get_hashi_latest_version "${name}")
        log_info "adding ${name} version ${version} to download-list ${download_list}"
        url="https://releases.hashicorp.com/${name}/${version}/${name}_${version}_linux_amd64.zip"
        echo "${url}" >>"${download_list}"
        echo " dir=/tmp/get-hashi" >>"${download_list}"
        echo " out=${name}.zip" >>"${download_list}"
    done
    if file_exists "${download_list}"; then
        pushd "/tmp/get-hashi/" >/dev/null 2>&1
        downloader "$download_list"
        [[ "$?" != 0 ]] && popd
        popd >/dev/null 2>&1
    fi
    local -r install_dir="/usr/bin/"
    for name in "${packages[@]}"; do
        extract "/tmp/get-hashi/${name}.zip" "$install_dir"
        mkdir -p "/etc/${name}/" "/var/${name}/"
        mkdir -p "/etc/${name}/" "/var/${name}/"
        chmod -R 0600 "/etc/${name}/" "/var/${name}/"
        chmod 0750 "/usr/bin/${name}"
        # fails gitpod build
        # @todo fix this
        # chown "${USER}:${USER}" "/usr/bin/${name}"
        if [[ "$name" == "vault" ]]; then
            setcap cap_ipc_lock=+ep /usr/bin/vault
        fi
        chmod +x "${install_dir}/${name}"
        rm -rf "/tmp/get-hashi/${name}.zip"
        # confirming install was successful
        # breaks gitpod build at the moment
        # $name --version >/dev/null
    done
}
export -f get_hashi_latest_version
export -f get_hashi 
function help() {
    echo
    echo "Usage: [$(basename "$0")] [OPTIONAL FLAG] [COMMAND | COMMAND <FLAG> <ARG>]"
    echo
    echo
    echo -e "[Synopsis]:\ta collection of file/folder operation helpers"
    echo
    echo -e "  r-md5\t\t\tRecursively generate md5 hashes in target dirs ."
    echo -e "  [flag|optional]\t--dupes \tonly list duplicates.[DEFAULT: 'false']"
    echo -e "  [flag|optional]\t--output <arg> \tTarget to store the list in.[DEFAULT: 'mdsums.list']"
    echo -e "  [flag(s)|optional]\t--dir <arg> \tDirectories to search.[DEFAULT: '$PWD']"
    echo
    echo -e "  dedup\t\t\tRecursively finds duplicate files in directory by comparing them"
    echo -e "\t\t\twith files in an origin directory ."
    echo -e "  \t\t\tIt does not delete duplicates in origin directory"
    echo -e "  [flag|optional]\t--output <arg> \tTarget to store the list of deleted files in."
    echo -e "  [flag]\t\t--origin <arg> \torigin directory."
    echo -e "  [flag(s)]\t\t--target <arg> \tdirectories to be deduplicated."
    echo
    echo
    echo "Optional Flags:"
    echo
    echo -e "  --init\t\tinitializes and installs dependancies for $(basename "$0")"
    echo -e "  --update\t\tupdates $(basename "$0") to the letest version at master branch."
    echo
    echo "Example:"
    echo
    echo "  sudo $(basename "$0") --init "
    echo
}
function update() {
    local -r url="https://raw.githubusercontent.com/da-moon/core-utils/master/bin/$(basename "$0")"
    local -r install_location=$(whereis "$(basename "$0")" | grep -E -o "$(basename "$0").*" | cut -f2- -d: | tr -s ' ' | cut -d ' ' -f2)
    log_info "updating $(basename "$0") located at $install_location"
    if [ ! -w "$install_location" ]; then
        log_info "needs sudo for updating file at $install_location"
        confirm_sudo
        [ "$(whoami)" = root ] || exec sudo "$0" "$@"
    fi
    log_info "removing old file at $install_location"
    rm "$install_location"
    log_info "downloading $url"
    wget -q -O "$install_location" "$url"
    log_info "setting $install_location as executable"
    chmod +x "$install_location"
}
function main() {
    if [[ $# == 0 ]]; then
        help
        exit
    fi
    while [[ $# -gt 0 ]]; do
        local key="$1"
        case "$key" in
        --init)
            log_info "initializing futils"
            init
            shift
            ;;
        --update)
            update
            shift
            ;;
        --help)
            help
            exit
            ;;
        *)
            log_error "Unrecognized option: $key"
            echo -e "\t\t\t\tRun '$(basename "$0") --help' for a list of known subcommands." >&2
            exit 1
            ;;
        esac
        shift
    done
}
if [ -z "${BASH_SOURCE+x}" ]; then
    main "${@}"
    exit $?
else
    if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
        main "${@}"
        exit $?
    fi
fi 
