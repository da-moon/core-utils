#!/usr/bin/env bash
set -o errtrace
set -o functrace
set -o errexit
set -o nounset
set -o pipefail
export PS4='+(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
function is_root() {
    [ "$EUID" -eq 0 ]
}
function string_colorify() {
    local -r input="$2"
    # checking for colour availablity
    ncolors=$(tput colors)
    if [[ $ncolors -ge 8 ]]; then
        local -r color_code="$1"
        echo -e "\e[1m\e[$color_code"m"$input\e[0m"
    else
        echo -e "$input"
    fi
}
function string_blue() {
    local -r color_code="34"
    local -r input="$1"
    echo -e "$(string_colorify "${color_code}" "${input}")"
}
function string_yellow() {
    local -r color_code="93"
    local -r input="$1"
    echo -e "$(string_colorify "${color_code}" "${input}")"
}
function string_green() {
    local -r color_code="32"
    local -r input="$1"
    echo -e "$(string_colorify "${color_code}" "${input}")"
}
function string_red() {
    local -r color_code="31"
    local -r input="$1"
    echo -e "$(string_colorify "${color_code}" "${input}")"
}
function log() {
    local -r level="$1"
    local -r message="$2"
    local -r timestamp=$(date +"%Y-%m-%d %H:%M:%S")
    local -r script_name="$(basename "$0")"
    local color
    case "$level" in
    INFO)
        color="string_green"
        ;;
    WARN)
        color="string_yellow"
        ;;
    ERROR)
        color="string_red"
        ;;
    esac
    echo >&2 -e "$(${color} "${timestamp} [${level}] ==>") $(string_blue "[$script_name]") ${message}"

}
function log_info() {
    local -r message="$1"
    log "INFO" "$message"
}
function log_warn() {
    local -r message="$1"
    log "WARN" "$message"
}
function log_error() {
    local -r message="$1"
    log "ERROR" "$message"
}
function file_exists() {
    local -r file="$1"
    [[ -f "$file" ]]
}
function os_command_is_available() {
    local name
    name="$1"
    command -v "$name" >/dev/null
}
function has_sudo() {
    os_command_is_available "sudo"
}
function has_apt() {
    os_command_is_available "apt-get"
}
function is_pkg_installed() {
    local -r pkg="$1"
    dpkg -s "$pkg" 2>/dev/null | grep ^Status | grep -q installed
}
function confirm_sudo() {
    log_info "apt-utils is not available ... installing now"
    if ! is_root; then
        log_error "needs root permission to run.exiting..."
        exit 1
    fi
    local target="sudo"
    if ! is_pkg_installed "apt-utils"; then
        log_info "apt-utils is not available ... installing now"
        apt-get -qq update &&
            DEBIAN_FRONTEND=noninteractive apt-get install -qqy apt-utils
    fi
    if ! has_sudo; then
        log_info "sudo is not available ... installing now"
        apt-get -qq update &&
            DEBIAN_FRONTEND=noninteractive apt-get install -qqy "$target"
    fi
}
function array_split() {
    local -r separator="$1"
    local -r str="$2"
    local -a ary=()
    IFS="$separator" read -ra ary <<<"$str"
    echo "${ary[@]}"
}
function apt_cleanup() {
    confirm_sudo
    if file_exists "/tmp/apt-fast.list"; then
        sudo rm /tmp/apt-fast.list
    fi
    sudo apt-get clean
    sudo rm -rf /var/lib/apt/lists/*
    sudo rm -rf /var/cache/apt/archives/*
}
function get_debian_codename() {
    local -r os_release=$(cat /etc/os-release)
    local -r version_codename_line=$(echo "$os_release" | grep -e VERSION_CODENAME)
    local -r result=$(string_strip_prefix "$version_codename_line" "VERSION_CODENAME=")
    echo "$result"
}
function assert_not_empty() {
    local -r arg_name="$1"
    local -r arg_value="$2"
    local -r reason="$3"
    if [[ -z "$arg_value" ]]; then
        log_error "'$arg_name' cannot be empty. $reason"
        exit 1
    fi
}
function append_line_to_file() {
    if [[ $# != 2 ]]; then
        echo
        echo "desc : adds a line to a file in case it hasn't already been added  "
        echo
        echo "method usage: append_line_to_file [target file] [line]"
        echo
        exit 1
    fi
    local -r dest="$1"
    local -r payload="$2"
    assert_not_empty "file path" "$dest" "needs a file path to work"
    assert_not_empty "line " "$payload" "needs a line to append to file"
    if [[ -z $(grep "$payload" "$dest") ]]; then
        echo "$payload" >>"$dest"
    fi
}
function add_to_bashrc() {
    if [[ $# != 1 ]]; then
        echo
        echo "desc : appends a line to .bashrc in case it hasn't been already added "
        echo
        echo "method usage: add_to_bashrc [line]"
        echo
        exit 1
    fi
    source "$HOME/.bashrc"
    local payload="$1"
    log_info "adding $payload to '\$HOME/.bashrc'"
    append_line_to_file "$HOME/.bashrc" "$payload"
    source "$HOME/.bashrc"
}
function add_profile_env_var() {
    if [[ $# != 2 ]]; then
        echo
        echo "desc : adds and exports a variable to .bashrc "
        echo
        echo "method usage: add_profile_env_var [variable name] [variable value]"
        echo
        exit 1
    fi
    local key="$1"
    local value="$2"
    add_to_bashrc "export $key=$value"
}
function add_to_path() {
    if [[ $# != 1 ]]; then
        echo
        echo "desc : adds a directory to path in case it hasn't been already added "
        echo
        echo "method usage: add_to_path [target directory]"
        echo
        exit 1
    fi
    local target_dir="$1"
    add_profile_env_var "PATH" "\$PATH:$target_dir"
}
function node_installer() {
    [ "$(whoami)" = root ] || exec sudo "$0" "$@"
    log_info "started procedure for installing node js"
    log_info "adding yarn apt repo key"
    curl -fsSL https://dl.yarnpkg.com/debian/pubkey.gpg | sudo apt-key add -
    echo "deb https://nightly.yarnpkg.com/debian/ nightly main" | sudo tee /etc/apt/sources.list.d/yarn-nightly.list
    apt-get -qq update
    log_info "running NodeSource Node.js 12.x installer script"
    curl -fsSL https://deb.nodesource.com/setup_12.x | sudo bash -
    # log_info "installing nvm"
    # curl -fsSL https://raw.githubusercontent.com/nvm-sh/nvm/v0.34.0/install.sh  | bash -
    local -r packages="nodejs,yarn"
    install_apts "$packages"
    add_to_path '`yarn global bin`'
    add_to_path '${home}/.yarn/bin'

}
function init() {
    if ! has_apt; then
        echo "apt not found. exiting ..."
        exit 1
    fi
    if ! os_command_is_available "wget"; then
        confirm_sudo
        echo "wget not found. installing ..."
        sudo apt-get update -qq && sudo apt-get install -yqq wget
        apt_cleanup
    fi
    if ! os_command_is_available "aria2c"; then
        confirm_sudo
        echo "aria2 not found. installing ..."
        sudo apt-get update -qq && sudo apt-get install -yqq aria2
        apt_cleanup
    fi
    if ! os_command_is_available "curl"; then
        confirm_sudo
        echo "curl not found. installing ..."
        sudo apt-get update -qq && sudo apt-get install -yqq curl
        apt_cleanup
    fi
    if ! os_command_is_available "ffmpeg"; then
        confirm_sudo
        echo "ffmpeg not found. installing ..."
        sudo apt-get update -qq && sudo apt-get install -yqq apt-transport-https
        curl -fsSL https://mkvtoolnix.download/gpg-pub-moritzbunkus.txt | sudo apt-key add -
        echo "deb https://mkvtoolnix.download/debian/ $(get_debian_codename) main" | sudo tee /etc/apt/sources.list.d/mkvtoolnix.download.list
        sudo apt-get update -qq && sudo apt-get install -yqq mkvtoolnix ffmpeg
        apt_cleanup
    fi
    if ! os_command_is_available "ffmpeg-bar"; then
        confirm_sudo
        echo "ffmpeg-bar not found. installing ..."
        if ! os_command_is_available "npm"; then
            node_installer
        fi
        sudo npm install --global ffmpeg-progressbar-cli
        apt_cleanup
    fi
}
function m3u8_downloader() {
    init
    local -r playlist_file="index.m3u8"
    local -r links="linx"
    local -r chunks_dir="/tmp/stream-dl-chunks"
    local -r name="$1"
    local -r url="$2"
    local -r stream_root=${url%/*}
    mkdir -p "${chunks_dir}/${name}"
    pushd "${chunks_dir}/${name}" >/dev/null 2>&1
    if file_exists "${links}"; then
        rm "${links}"
    fi
    if file_exists "${playlist_file}"; then
        rm "${playlist_file}"
    fi
    wget -qnc "${url}" -O "${playlist_file}"
    for i in $(grep -Ev '#EXT' ${playlist_file}); do
        echo "${stream_root}/${i}" >>"${links}"
    done
    aria2c -i "${links}" \
        -j 16 \
        --continue=true \
        --max-connection-per-server=16 \
        --optimize-concurrent-downloads
    [[ "$?" != 0 ]] && popd
    popd >/dev/null 2>&1
    ffmpeg-bar -nostdin -allowed_extensions ALL -i "${chunks_dir}/${name}/${playlist_file}" -c copy "${name}.mkv"
    rm -rf "${chunks_dir}/${name}"
}
function help() {
    echo
    echo "Usage: [stream-dl] [OPTIONAL ARG] [COMMAND | COMMAND <FLAG> <ARG>]"
    echo
    echo
    echo -e "[Synopsis]:\tuses aria2 to download m3u8 streams and converts them to mkv with ffmpeg"
    echo
    echo -e "[hint]:\t\tuse the following to read playlist links from file in which"
    echo -e "\t\t| is used as seperator; i.e. {URL}|{name}.do not put extention in name."
    echo -e "\t\tdo not keep file extention in name."
    echo
    echo -e "while IFS='|' read -r url name;do stream-dl \"\$name\" \"\$url\"< /dev/null ; done <linx"
    echo
    echo "Optional Flags:"
    echo
    echo -e "  --init\t\tinitializes and installs dependancies."
    echo
    echo "Example:"
    echo
    echo "  sudo stream-dl --init "
    echo
    echo "  stream-dl \\"
    echo "      \${name} \\"
    echo "      \${link} "
    echo
}
function main() {
    if [[ $# == 0 ]]; then
        help
        exit
    fi
    while [[ $# -gt 0 ]]; do
        local key="$1"

        case "$key" in
        --init)
            shift
            log_info "initializing fast apt by downloading base packages and upgrading exisiting ones"
            init
            exit
            ;;
        *)
            m3u8_downloader "${@}"
            exit $?
            ;;
        esac
        shift
    done
}

if [ "${BASH_SOURCE[0]}" != "${0}" ]; then
    export -f m3u8_downloader
else
    main "${@}"
    exit $?
fi
